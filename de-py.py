from typing import Dict, List, Tuple
from collections import defaultdict

"""
write a function which returns the largest positive number 
that can be generated by rearranging the digits of another positive number.

Example: 1001
Result:  1100

sort
"""

def find_largest_number(num: int) -> int:
    # num is a positive number
    # convert the number to a list of digits
    digits = list(str(num))
    # sort the digits in descending order
    digits.sort(reverse=True)
    # convert the list of digits back to an integer
    return int(''.join(digits))

# time: O(nlogn)

"""
given a mapping between book titles and the themes they contain, 
find the theme which appears the most times. 
If multiple themes appear the same number of times, return any one of them.

Example: {
    "The Time Machine": ["Time travel", "Rebuilding civilization", "Language barriers"],
    "The Danger Trail": ["Redemption",  "Rebuilding civilization"],
    "Success Story":    ["Hope"],
}
Result: "Rebuilding civilization"

hashmap
"""

def find_most_theme(title_theme: Dict[str, List[str]]) -> str:
    # map: title -> [themes]
    # map: theme -> counts
    theme_count = defaultdict(int)
    for themes in title_theme.values():
        for theme in themes:
            theme_count[theme] += 1
    # return the map's key with the max value
    return max(theme_count, key=theme_count.get) 


"""
given a list of meetings with the hours they started and ended at (as numbers from 1 to 24), and the size of their audience, 
return the largest total number of people that attended meetings simultaneously, across a continuous period of time. 

Example: [
    Meeting(title = "The Age of Fiction",   audience = 10, start = 1, end = 4),
    Meeting(title = "Audiobook Publishing", audience = 20, start = 3, end = 8),
    Meeting(title = "National Novel Month", audience = 30, start = 5, end = 8),
]

Result: 50
Explanation: The largest number of people attended between 5:00 and 8:00,
when the last two meetings were taking place at the same time.

hashmap
"""

def find_max_audience(meetings) -> int:
    # meetings: class Meetings
    # map: hour -> total size of audience
    # return the max of map.values
    hour_size = defaultdict(int)
    for meeting in meetings:
        for hour in range(meeting.start, meeting.end):
            hour_size[hour] += meeting.audience
    return max(hour_size.values()) 

    # time: O(n * h) h is the average duration of a meeting


def max_attendance(meetings):
    # Create events list with (time, audience_change)
    events = []
    for meeting in meetings:
        # When meeting starts, audience increases
        events.append((meeting.start, meeting.audience))
        # When meeting ends, audience decreases
        events.append((meeting.end, -meeting.audience))
    
    # Sort events by time
    events.sort()
    
    current_attendance = 0
    max_attendance = 0
    
    # Process events in time order
    for time, audience_change in events:
        current_attendance += audience_change
        max_attendance = max(max_attendance, current_attendance)
    
    return max_attendance

    # time: O(nlogn) bc of sorting

"""
given the maximum book size that each shelf can store (also known as its capacity) 
and the size of each book, 
determine if all the books can fit on the shelves. 
Assume that only one book can be placed on each shelf.

sort
zip(higher-order function)
"""

def can_fit_books(capacities: List[int], sizes: List[int]) -> bool:
    # capacities: List[int]
    # sizes: List[int]
    # return True if all books can fit on the shelves, False otherwise
    capacities.sort()
    sizes.sort()
    for capacity, size in zip(capacities, sizes):
        if capacity < size:
            return False
    return True

"""
Find the avg from the list. 
Make sure read the test cases which they will metion below question and write edge case accordingly that will save time.
--Test cases passed sum =0

if list is "None":
    return "passed None"
elif len[list] == 0:
    return "List empty passed"		

for i in list:
    sum +=list[i]
    avg = sum/len(list)
return avg
"""

def find_avg(nums: List[int]) -> float:
    # nums: List[int]
    # return the avg of the list
    if nums is None:
        return 0
    if len(nums) == 0:
        return 0
    sum = 0
    for i in nums:
        sum += i
    avg = sum / len(nums)
    return avg


"""
List contains item prices and there will be budget 
find how many items can you buy? --Test cases passed
  
  
Prices [ 10.0 , 5.0 , 20.0] Budget 35
  
item_cnt = 0
total = 0
for i , v in enumerate(prices):
    if   total  < budget and  budget > v:
            total += v
            item_cnt += 1
return item_cnt

At end i was able to complete 2 from each section. They will give next question only when  you execute the current question.

sort
"""

def max_items(prices: List[int], budget: int) -> int:
    # prices: List[int]
    # budget: int
    # return the number of items that can be bought
    prices.sort()
    cnt = 0
    for price in prices:
        if budget > 0:
            budget -= price
            cnt += 1
    return cnt


"""
coding 五道：一) 由于有给test case但有很多cornor case建议看完题后先处理cornor case，第一题问一句话里某个字符串重复的次数
                           二）给两个包含数字的列表，求两个列表里不重复的数字，不用在意输出顺序
                           三）给一个数字列表且里面有None，重新输出一遍把None位置的数用前面存在的数代替
                           四）给一个字典，求字典值里第N大的值的键
                           五）给一个数字列表且某些数字重复，给出每个数字还需要加进多少个才能使得列表里每个数字都一样多


"""